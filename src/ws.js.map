{"version":3,"file":"ws.js","sourceRoot":"","sources":["ws.ts"],"names":[],"mappings":"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","sourcesContent":["import * as WebSocket from \"ws\";\r\nimport {\r\n    ErrorMessage, isChannelMessage,\r\n    isConnectMessage,\r\n    isPingMessage, isRequestPing,\r\n    Message,\r\n    MetadataMessage,\r\n} from \"grage-lib/lib\";\r\n\r\nfunction debug(...args: any) {\r\n    if (process.env.DEBUG === 'true')\r\n        console.log(...args);\r\n}\r\n\r\nexport default function makeWss(options = {\r\n    connectionTimeout: 60 * 1000,\r\n    ping: 60 * 1000,\r\n}) {\r\n    const channels: {\r\n        [id: string]: WebSocket[];\r\n    } = {};\r\n\r\n    function getClients(id: string) {\r\n        if (!channels.hasOwnProperty(id))\r\n            channels[id] = [];\r\n        return channels[id];\r\n    }\r\n\r\n    let currentID = 1;\r\n\r\n    return function handleConnection(me: WebSocket) {\r\n        const clientID = currentID++;\r\n        console.log('[client connected]', clientID);\r\n\r\n        const connectedChannels: string[] = [];\r\n        // const timers: { [id: string]: NodeJS.Timeout } = {};\r\n\r\n        //regularly send ping with metadata\r\n        const metadataTimer = setInterval(function sendMetadata() {\r\n            const meta: MetadataMessage = {\r\n                type: 'metadata',\r\n                connectedChannels,\r\n                ...options,\r\n            };\r\n            me.send(JSON.stringify(meta), handleError);\r\n        }, options.ping);\r\n\r\n        /**\r\n         * Connects to a channel.\r\n         * Only renews timeout if already connected.\r\n         * @param id the id of the channel to connect to\r\n         */\r\n        function connect(id: string) {\r\n            //connect to channel\r\n            const clients = getClients(id);\r\n\r\n            //only add if already\r\n            if (!clients.includes(me)) {\r\n                clients.push(me);\r\n                connectedChannels.push(id);\r\n            }\r\n\r\n            //automatically disconnect if timeout occurs\r\n            // if (timers.hasOwnProperty(id)) {\r\n            //     //clear any old timer\r\n            //     clearTimeout(timers[id]);\r\n            // }\r\n            //\r\n            // //store timeout in case we need to clear it later (see above)\r\n            // timers[id] = setTimeout(() => disconnect(id), options.connectionTimeout+1000);\r\n        }\r\n\r\n        /**\r\n         * Disconnects this client from a channel.\r\n         * Does not throw error if client is not connected to channel.\r\n         * @param id the channel to disconnect from\r\n         */\r\n        function disconnect(id: string) {\r\n            //remove from list of clients in channel\r\n            const clients = getClients(id);\r\n            const idx = clients.indexOf(me);\r\n            if (idx !== -1)\r\n                clients.splice(idx, 1);\r\n\r\n            //remove from list of channels this is connected to\r\n            const idx2 = connectedChannels.indexOf(id);\r\n            if (idx2 !== -1)\r\n                connectedChannels.splice(idx2, 1);\r\n        }\r\n\r\n        /**\r\n         * Terminates this websocket connection,\r\n         * and cleans up from all connected channels\r\n         */\r\n        function terminate() {\r\n            console.log('[client disconnected]', clientID);\r\n\r\n            //stop sending metadata\r\n            clearInterval(metadataTimer);\r\n\r\n            //disconnect websocket if not already\r\n            if (me.readyState === WebSocket.CONNECTING || me.readyState === WebSocket.OPEN) {\r\n                me.terminate();\r\n            }\r\n\r\n            //clean up connections to channels\r\n            for (const id of connectedChannels) {\r\n                disconnect(id);\r\n            }\r\n        }\r\n\r\n        me.on('close', terminate);\r\n\r\n        /**\r\n         * Handles when any user induced error occurs\r\n         * @param error the error which occurred\r\n         */\r\n        function handleError(error?: Error) {\r\n            //allows this function to be directly used in callbacks\r\n            //where the error is undefined upon success\r\n            if (error === undefined) {\r\n                return;\r\n            }\r\n\r\n            console.error(`[client ${clientID} error]`, error);\r\n\r\n            //try to tell client what went wrong\r\n            const errMsg: ErrorMessage = {\r\n                type: \"error\",\r\n                error: (error.stack || 'No stack trace').toString(),\r\n            };\r\n            me.send(JSON.stringify(errMsg), (e) => {\r\n                if (e) {\r\n                    //this prints if send failed\r\n                    console.error('Error while sending error', e);\r\n                }\r\n                //terminate connection no matter what\r\n                terminate();\r\n            });\r\n        }\r\n\r\n        //let messageTimeout: NodeJS.Timeout | undefined;\r\n        me.on('message', function incoming(message) {\r\n            debug(`[client ${clientID}]`, message);\r\n            //disconnect client if they are inactive for a long time\r\n            // if (messageTimeout) {\r\n            //     clearInterval(messageTimeout);\r\n            // }\r\n            // messageTimeout = setTimeout(terminate, options.connectionTimeout);\r\n\r\n            try {\r\n                const m = JSON.parse(message.toString()) as Message;\r\n\r\n                if (isChannelMessage(m)) {\r\n                    //send to every client in certain channel\r\n                    for (const client of getClients(m.id)) {\r\n                        //skip me (person who sent message)\r\n                        if (client !== me)\r\n                            client.send(JSON.stringify(m), handleError);\r\n                    }\r\n                } else if (isConnectMessage(m)) {\r\n                    connect(m.id);\r\n                }else {\r\n                    handleError(new Error(`Invalid message type: ${m.type}`));\r\n                }\r\n            } catch (error) {\r\n                handleError(error);\r\n            }\r\n        });\r\n    }\r\n}\r\n"]}